{"version":3,"file":"puremvc-async-command.min.js","sources":["../../src/AsyncCommand.js","../../src/AsyncMacroCommand.js"],"sourcesContent":["/*\n PureMVC MultiCore Utility for JS - AsyncCommand\n Copyright(c) 2008 Duncan Hall <duncan.hall@puremvc.org>\n              2024 Cliff Hall <cliff.hall@puremvc.org>\n Your reuse is governed by the Creative Commons Attribution 3.0 License\n*/\nimport {SimpleCommand, Notifier} from '@puremvc/puremvc-js-multicore-framework';\n\n/**\n * A base IAsyncCommand implementation.\n *\n * Your subclass should override the `execute`\n * method where your business logic will handle the <code>Notification</code>. </P>\n *\n * @see AsyncMacroCommand\n */\nexport class AsyncCommand extends SimpleCommand {\n\n    /**\n     * Registers the callback for a parent <code>AsyncMacroCommand</code>.\n     *\n     * @param callback\tThe <code>AsyncMacroCommand</code> method to call on completion\n     */\n    setOnComplete ( callback )\n    {\n        this.onComplete = callback;\n    }\n\n    /**\n     * Notify the parent AsyncMacroCommand that this command is complete.\n     *\n     * Call this method from your subclass to signify that your asynchronous\n     * command has finished.\n     */\n    commandComplete()\n    {\n        this.onComplete();\n    }\n\n    onComplete;     // the callback to invoke on command completion\n    isAsync = true; // simplest workaround to lack of interfaces\n}\n","/*\n PureMVC MultiCore Utility for JS - AsyncCommand\n Copyright(c) 2008 Duncan Hall <duncan.hall@puremvc.org>\n              2024 Cliff Hall <cliff.hall@puremvc.org>\n Your reuse is governed by the Creative Commons Attribution 3.0 License\n*/\nimport {Notifier} from \"@puremvc/puremvc-js-multicore-framework\";\n\n/**\n * A base Command implementation that executes other\n * Commands asynchronously.\n \n * An AsyncMacroCommand maintains a list of\n * factories that create SubCommands.\n \n * When execute is called, the AsyncMacroCommand\n * caches a reference to the Notification and calls\n * nextCommand.\n \n * If there are still SubCommands to be executed,\n * the nextCommand method instantiates and calls\n * execute on each of its SubCommands in turn.\n *\n * Each SubCommand will be passed a reference to the\n * original Notification that was passed to the\n * AsyncMacroCommand's execute method. If the\n * SubCommand to execute is an IAsyncCommand, the\n * next SubCommand will not be executed until the\n * previousAsyncCommand has called its commandComplete\n * method.\n \n * Unlike AsyncCommand and SimpleCommand, your subclass\n * should not override execute, but instead, should\n * override the initializeAsyncMacroCommand method,\n * calling addSubCommand once for each SubCommand\n * to be executed.\n *\n * @see AsyncCommand\n */\nexport class AsyncMacroCommand extends Notifier\n{\n\n    /**\n     * Constructor.\n     \n     * You should not need to define a constructor,\n     * instead, override the initializeAsyncMacroCommand\n     * method.\n     \n     * If your subclass does define a constructor, be\n     * sure to call super().\n     */\n    constructor()\n    {\n        super();\n        this.subCommands = [];\n        this.initializeAsyncMacroCommand();\n    }\n\n    /**\n     * Initialize the AsyncMacroCommand.\n     *\n     * In your subclass, override this method to\n     * initialize the AsyncMacroCommand's SubCommand\n     * list with factories like this:\n     *\n     *\t\t// Initialize MyMacroCommand\n     *\t\tfunction initializeAsyncMacroCommand()\n     *\t\t{\n     *\t\t\taddSubCommand( () => new FirstCommand );\n     *\t\t\taddSubCommand( () => new SecondCommand );\n     *\t\t\taddSubCommand( () => new ThirdCommand );\n     *\t\t}\n     *\n     * SubCommands should extend one of the following\n     * - AsyncMacroCommand\n     * - AsyncCommand\n     * - MacroCommand \n     * - SimpleCommand\n     */\n    initializeAsyncMacroCommand(){}\n\n    /**\n     * Add a SubCommand.\n     *\n     * The SubCommands will be called in First In/First Out (FIFO)\n     * order.\n     *\n     * @param factory a function that instantiates the subcommand\n     */\n    addSubCommand( factory ) { this.subCommands.push( factory );}\n\n    /**\n     * Registers the callback for a parent AsyncMacroCommand.\n     *\n     * @param callback\tThe AsyncMacroCommand method to call on completion\n     */\n    setOnComplete ( callback ) { this.onComplete = callback; }\n\n    /**\n     * Starts execution of this AsyncMacroCommand's SubCommands.\n     *\n     * The SubCommands will be called in First In/First Out (FIFO) order.\n     *\n     * @param notification the Notification object to be passed to each SubCommand.\n     */\n    execute( notification )\n    {\n        this.note = notification;\n        this.nextCommand();\n    }\n\n    /**\n     * Execute this AsyncMacroCommand's next SubCommand.\n     *\n     * If the next SubCommand is asynchronous, a callback is registered for\n     * the command completion, else the next command is run.\n     */\n    nextCommand()\n    {\n        if (this.subCommands?.length > 0)\n        {\n            const factory = this.subCommands.shift();\n            const instance\t= factory();\n            let isAsync\t= ( instance?.isAsync === true );\n            if (isAsync) instance.setOnComplete( () => this.nextCommand() );\n            instance.initializeNotifier( this.multitonKey );\n            instance.execute( this.note );\n            if (!isAsync) this.nextCommand();\n        } else {\n            if( this?.onComplete ) this.onComplete();\n            this.note = null;\n            this.onComplete\t= null;\n        }\n    }\n\n    note;           // Notification\n    subCommands;    // Array of command subcommand factories\n    onComplete;     // Optional function to call when the AsyncMacro completes\n    isAsync = true; // simplest workaround to lack of interfaces\n}"],"names":["AsyncCommand","SimpleCommand","setOnComplete","callback","this","onComplete","commandComplete","isAsync","AsyncMacroCommand","Notifier","constructor","super","subCommands","initializeAsyncMacroCommand","addSubCommand","factory","push","execute","notification","note","nextCommand","length","instance","shift","initializeNotifier","multitonKey"],"mappings":"sFAgBO,MAAMA,UAAqBC,EAO9B,aAAAC,CAAgBC,GAEZC,KAAKC,WAAaF,CACrB,CAQD,eAAAG,GAEIF,KAAKC,YACR,CAEDA,WACAE,SAAU,ECDP,MAAMC,UAA0BC,EAanC,WAAAC,GAEIC,QACAP,KAAKQ,YAAc,GACnBR,KAAKS,6BACR,CAuBD,2BAAAA,GAA+B,CAU/B,aAAAC,CAAeC,GAAYX,KAAKQ,YAAYI,KAAMD,EAAU,CAO5D,aAAAb,CAAgBC,GAAaC,KAAKC,WAAaF,CAAW,CAS1D,OAAAc,CAASC,GAELd,KAAKe,KAAOD,EACZd,KAAKgB,aACR,CAQD,WAAAA,GAEI,GAAIhB,KAAKQ,aAAaS,OAAS,EAC/B,CACI,MACMC,EADUlB,KAAKQ,YAAYW,OAChBR,GACjB,IAAIR,GAAkC,IAAtBe,GAAUf,QACtBA,GAASe,EAASpB,eAAe,IAAME,KAAKgB,gBAChDE,EAASE,mBAAoBpB,KAAKqB,aAClCH,EAASL,QAASb,KAAKe,MAClBZ,GAASH,KAAKgB,aAC/B,MACgBhB,MAAMC,YAAaD,KAAKC,aAC5BD,KAAKe,KAAO,KACZf,KAAKC,WAAa,IAEzB,CAEDc,KACAP,YACAP,WACAE,SAAU"}